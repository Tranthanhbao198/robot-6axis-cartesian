import numpy as np
import math
from robot6.robot import Simple6DOF, rad
from robot6.kinematics import Pose

def test_fk_reaches_expected_pose():
    """FK at q=[0]*6 matches standard-DH expected position."""
    robot = Simple6DOF()
    q_zero = np.zeros(6)
    T, _ = robot.fk(q_zero)

    # Expected from current standard DH chain:
    expected_position = np.array([-0.81725, -0.23290, 0.06280])

    assert T.shape == (4, 4)
    assert np.allclose(T[:3, 3], expected_position, atol=1e-4)

def test_ik_fk_consistency():
    """IK should solve for a target pose generated by FK (round-trip)."""
    robot = Simple6DOF()
    q_seed = np.array([rad(15), rad(-75), rad(80), rad(-15), rad(60), rad(-20)], dtype=float)

    assert robot.within_limits(q_seed)
    T_target, _ = robot.fk(q_seed)
    target_pose = Pose(T_target[:3, 3], T_target[:3, :3])

    # harder initial guess
    q_guess = q_seed + np.random.uniform(-0.1, 0.1, 6)

    q_solution, ok = robot.ik(target_pose, q_guess)
    assert ok

    T_solution, _ = robot.fk(q_solution)
    pos_error = np.linalg.norm(T_solution[:3, 3] - target_pose.p)
    assert pos_error < 1e-3

